<html>
    <!-- import random
def docfile():
	f = open('answer.txt', 'r')
	line= f.readlines()
	f.close()
	# x=[i[:-1] for i in line if '\n' in i ] 
	# x.append(line[len(line)-1])
	return line

def checkQueen(x):
	for i in x :
		pass
	pass


# if __name__ == "__main__":
# 	for i in range(0,10):
# 		print(random.randint(1,100))
	
""" Python3 code for inorder succesor  
and predecessor of tree """
  
# A Binary Tree Node  
# Utility function to create a new tree node  
class getnode:  
  
    # Constructor to create a new node  
    def __init__(self, data):  
        self.data = data  
        self.left = None
        self.right = None
  
"""  
since inorder traversal results in  
ascendingorder visit to node , we  
can store the values of the largest  
o which is smaller than a (predecessor)  
and smallest no which is large than  
a (succesor) using inorder traversal  
"""
def find_p_s(root, a, p, q):  
  
    # If root is None return  
    if(not root): 
        return
          
    # traverse the left subtree      
    find_p_s(root.left, a, p, q)  
      
    # root data is greater than a  
    if(root and root.data > a): 
          
        # q stores the node whose data is greater  
        # than a and is smaller than the previously  
        # stored data in *q which is sucessor  
        if((not q[0]) or q[0] and 
                q[0].data > root.data): 
            q[0] = root 
              
    # if the root data is smaller than  
    # store it in p which is predecessor  
    elif(root and root.data < a): 
        p[0]= root  
      
    # traverse the right subtree  
    find_p_s(root.right, a, p, q) 
  
# Driver Code 
if __name__ == '__main__':  
  
    root1 = getnode(50)  
    root1.left = getnode(20)  
    root1.right = getnode(60)  
    root1.left.left = getnode(10)  
    root1.left.right = getnode(30)  
    root1.right.left = getnode(55)  
    root1.right.right = getnode(70)  
    p = [None] 
    q = [None]  
      
    find_p_s(root1, 55, p, q)  
      
    if(p[0]) : 
        print(p[0].data, end = "") 
    if(q[0]) : 
        print("", q[0].data) 
  
# This code is contributed by  
# SHUBHAMSINGH10  -->
<p>hello</p>
</html>